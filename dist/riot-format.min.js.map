{"version":3,"file":null,"sources":["../src/opts.js","../src/format.js","../src/formatters/number.js","../src/formatters/bytes.js","../src/formatters/json.js","../src/index.js","../src/formatter.js","../src/formatters/date.js","../src/formatters/index.js"],"sourcesContent":["const DEFAULT_ERROR = '!ERR!'\r\n\r\nconst opts = {\r\n    /**\r\n     * represents that error occurs when evaluted formatters\r\n     */ \r\n    err: DEFAULT_ERROR\r\n}\r\n\r\nexport default opts\r\n\r\nexport function getOption(key){\r\n    let val = opts[key]\r\n    if(key == 'err' && (typeof val === 'undefined' || val == null)){\r\n        return DEFAULT_ERROR\r\n    }\r\n    return val\r\n}","import Formatter from './formatter'\nimport opts from './opts'\n\nconst slice = Array.prototype.slice\n\n/**\n * Forbidden names when define formatters or retrieve formatter\n * @constant\n */\nconst ForbiddenMethods = ['value', 'toString', 'valueOf', '_value', '_error', '_chains']\n\n/**\n* format a given value in the riot tag context\n* @example <caption>use it globally</caption>\n* format(new Date(), 'date');\n* @example <caption>use it with riot</caption>\n* window.format = format;\n* \n* //define a riot tag\n*   <app>\n*      <p> {format(new Date(), 'date', 'yyyy-mm-dd HH:MM:ss')} </p>\n*   </app>\n* @param {any} value      the value passed in to be formatted\n* @param {string} method  the format method to be used\n* @returns {Formatter} the Formatter instance\n*/\nexport function format (value, method) {\n    const self = new Formatter(value)\n    const args = slice.call(arguments, 2)\n    if (typeof method == 'string') {\n        if(ForbiddenMethods.indexOf(method)!==-1){\n            console.warn('ignored, not allowed method name: ' + method)\n            return\n        }\n\n        const fn = self[method]\n        if (typeof fn === 'function') {\n            fn.apply(self, args)\n        }else if(!fn){\n            throw new Error('method not found: ' + method)\n        }\n    }\n    return self\n}\n\nformat.opts = opts\n\n/**\n * @param {String} method method name\n * @param {Function} fn method body\n */\nfunction defineFormatter (method, fn) {\n    if (typeof method == 'string' && typeof fn == 'function') {\n        if(ForbiddenMethods.indexOf(method)!==-1){\n            throw new Error('not allowed method name: ' + method)\n        }\n\n        const format = function () {\n            const args = slice.call(arguments, 0)\n            let chains = this._chains\n            if(!chains){\n                chains = []\n            }\n            chains.push(function(value){\n                args.unshift(value)\n                return fn.apply(null, args)\n            })\n            this._chains = chains\n            return this\n        }\n        format._def = fn\n        Formatter.prototype[method] = format\n        return\n    }\n    throw new Error('check your parameters')\n}\n\n/**\n * @description extend with custom formatters\n * @example\n *  extend('yesno', function(input){\n *      return !!input ? 'yes' : 'no';\n *  });\n * @example\n *  extend({\n *      yes: function(input){\n *          return !!input ? 'yes' : '';\n *      },\n *      no: function(input){\n *          return !!!input ? 'no' : '';\n *      }\n *  });\n * \n * @param {String|Object} name if name is Object, means mutiple format methods;\n *  otherwise it is method name, should be used with fn\n * @param {Function} fn should be used if name is String\n */\nexport function extend (name, fn) {\n    if (typeof name === 'object') {\n        const obj = name\n        for (let key in obj) {\n            defineFormatter(key, obj[key])\n        }\n    }else {\n        defineFormatter(name , fn)\n    }\n}\n","export default function number (input, fractionSize) {\n    if (fractionSize === void 0 || fractionSize < 0) {\n        fractionSize = 2\n    }\n    const num = Number(input)\n    if (isNaN(num.valueOf())) {\n        return input\n    }\n    if (!isFinite(num.valueOf())) {\n        return num.valueOf() < 0 ? '-∞' : '∞'\n    }\n    return num.toFixed(fractionSize).replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,')\n}\n","export default function bytes (input, fractionSize = 2 , defaultValue = '--') {\n    const num = Number(input)\n\n    if (isNaN(num.valueOf()) || num < 0) {\n        return defaultValue\n    }\n    if (fractionSize < 0) {\n        fractionSize = 2\n    }\n\n    if (num < 1024) {\n        return num.toFixed(0) + ''\n    }\n    if (num < 1024 * 1024) {\n        return (num / 1024).toFixed(fractionSize) + 'K'\n    }\n    if (num < 1024 * 1024 * 1024) {\n        return (num / (1024 * 1024)).toFixed(fractionSize) + 'M'\n    }\n    return (num / (1024 * 1024 * 1024)).toFixed(fractionSize) + 'G'\n}\n","export default function json (input) {\n    return JSON.stringify(input)\n}\n","import { format, extend } from './format'\n\n// import built-in formatters\nimport './formatters'\n\n/**\n * mixin format globally\n * @param {any} riot riot module object\n * @example\n * import * as riot from 'riot';\n * use(riot);\n */\nexport function use(riot) {\n    riot.mixin({format})\n}\n\n/**\n * same as extend()\n * @see extend\n * @deprecated\n */\nuse.define = function (...args) {\n    console.warn('define() is deprecated, use extend() instead.')\n    return extend(...args)\n}\n\nuse.extend = extend\n\nuse.format = format\n\n// use.Formatter = Formatter\nexport { format, extend } from './format'\n\nexport default use","import { getOption } from './opts'\n\n/**\n * a decorator class to format value\n * @class\n */\nexport default class Formatter {\n    constructor (value) {\n        this._value = value\n        //this._lazyValue = null\n        //this[CHAINS_CALL] = null\n    }\n\n  /**\n   * @description format the value to String\n   * @returns {String}\n   */\n    toString () {\n        let val = this.current\n        if(val === null || typeof val === 'undefined'){\n            return ''\n        }\n        return String(this.current)\n    }\n\n    /**\n     * the original value passed in\n     * \n     * @readonly\n     * \n     * @memberOf Formatter\n     */\n    get value(){\n        return this._value\n    }\n\n    /**\n     * the evaluated value by chained formatters\n     * \n     * @readonly\n     * \n     * @memberOf Formatter\n     */\n    get current(){\n        //check error\n        if(this._error){\n            console.error(this._error)\n            return getOption('err')\n        }\n\n        if('_lazyValue' in this){\n            return this._lazyValue\n        }\n\n        const chains = this._chains\n        //no chains\n        if(!chains){\n            return this._value\n        }\n\n        delete this._chains\n        delete this._lazyValue\n        delete this._error\n\n        //eval chains\n        try {\n            let val = this._value\n            for(let i=0; i< chains.length; i++){\n                val = chains[i](val)\n            }\n            this._lazyValue = val\n            return val\n        } catch (e) {\n            this._error = e\n            console.error(e)\n        }\n        return getOption('err')\n    }\n\n   /**\n   * deprecated, use current\n   * @deprecated\n   */\n    valueOf () {\n        console.warn('deprecated, will be removed in future')\n        return this.current\n    }\n}\n\n","// taken from http://stevenlevithan.com/assets/misc/date.format.js\n/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\nvar dateFormat = function () {\n    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|\"[^\"]*\"|'[^']*'/g,\n        timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n        timezoneClip = /[^-+\\dA-Z]/g,\n        pad = function (val, len) {\n            val = String(val)\n            len = len || 2\n            while (val.length < len) val = '0' + val\n            return val\n        }\n\n  // Regexes and supporting functions are cached through closure\n    return function (date, mask, utc) {\n        var dF = dateFormat\n\n    // You can't provide utc if you skip other args (use the \"UTC:\" mask prefix)\n        if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\\d/.test(date)) {\n            mask = date\n            date = undefined\n        }\n\n    // Passing date through Date applies Date.parse, if necessary\n        date = date ? new Date(date) : new Date()\n        if (isNaN(date)) throw SyntaxError('invalid date')\n\n        mask = String(dF.masks[mask] || mask || dF.masks['default'])\n\n    // Allow setting the utc argument via the mask\n        if (mask.slice(0, 4) == 'UTC:') {\n            mask = mask.slice(4)\n            utc = true\n        }\n\n        var _ = utc ? 'getUTC' : 'get',\n            d = date[_ + 'Date'](),\n            D = date[_ + 'Day'](),\n            m = date[_ + 'Month'](),\n            y = date[_ + 'FullYear'](),\n            H = date[_ + 'Hours'](),\n            M = date[_ + 'Minutes'](),\n            s = date[_ + 'Seconds'](),\n            L = date[_ + 'Milliseconds'](),\n            o = utc ? 0 : date.getTimezoneOffset(),\n            flags = {\n                d: d,\n                dd: pad(d),\n                ddd: dF.i18n.dayNames[D],\n                dddd: dF.i18n.dayNames[D + 7],\n                m: m + 1,\n                mm: pad(m + 1),\n                mmm: dF.i18n.monthNames[m],\n                mmmm: dF.i18n.monthNames[m + 12],\n                yy: String(y).slice(2),\n                yyyy: y,\n                h: H % 12 || 12,\n                hh: pad(H % 12 || 12),\n                H: H,\n                HH: pad(H),\n                M: M,\n                MM: pad(M),\n                s: s,\n                ss: pad(s),\n                l: pad(L, 3),\n                L: pad(L > 99 ? Math.round(L / 10) : L),\n                t: H < 12 ? 'a' : 'p',\n                tt: H < 12 ? 'am' : 'pm',\n                T: H < 12 ? 'A' : 'P',\n                TT: H < 12 ? 'AM' : 'PM',\n                Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),\n                o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n                S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n            }\n\n        return mask.replace(token, function ($0) {\n            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)\n        })\n    }\n}()\n\n// Some common format strings\ndateFormat.masks = {\n    'default': 'ddd mmm dd yyyy HH:MM:ss',\n    shortDate: 'm/d/yy',\n    mediumDate: 'mmm d, yyyy',\n    longDate: 'mmmm d, yyyy',\n    fullDate: 'dddd, mmmm d, yyyy',\n    shortTime: 'h:MM TT',\n    mediumTime: 'h:MM:ss TT',\n    longTime: 'h:MM:ss TT Z',\n    isoDate: 'yyyy-mm-dd',\n    isoTime: 'HH:MM:ss',\n    isoDateTime: 'yyyy-mm-dd\\'T\\'HH:MM:ss',\n    isoUtcDateTime: 'UTC:yyyy-mm-dd\\'T\\'HH:MM:ss\\'Z\\''\n}\n\n// Internationalization strings\ndateFormat.i18n = {\n    dayNames: [\n        'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',\n        'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n    ],\n    monthNames: [\n        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',\n        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'\n    ]\n}\n\n\ndateFormat.polyfill = function () {\n    // For convenience...\n    \n    /*jshint -W121 */\n    Date.prototype.format = function (mask, utc) {\n        return dateFormat(this, mask, utc)\n    }\n    /*jshint +W121 */\n}\n\nexport default dateFormat\n","import { extend} from '../format'\n\nimport date from  './date'\nimport number from './number'\nimport bytes from './bytes'\nimport json from './json'\n\nextend({date, number,bytes,json})"],"names":["getOption","key","let","val","opts","DEFAULT_ERROR","format","value","method","const","self","Formatter","args","slice","call","arguments","ForbiddenMethods","indexOf","console","warn","fn","apply","Error","defineFormatter","chains","this","_chains","push","unshift","_def","prototype","extend","name","obj","number","input","fractionSize","num","Number","isNaN","valueOf","isFinite","toFixed","replace","bytes","defaultValue","json","JSON","stringify","use","riot","mixin","err","_value","toString","current","String","prototypeAccessors","_error","error","_lazyValue","i","length","e","Array","dateFormat","token","timezone","timezoneClip","pad","len","date","mask","utc","dF","Object","test","undefined","Date","SyntaxError","masks","_","d","D","m","y","H","M","s","L","o","getTimezoneOffset","flags","dd","ddd","i18n","dayNames","dddd","mm","mmm","monthNames","mmmm","yy","yyyy","h","hh","HH","MM","ss","l","Math","round","t","tt","T","TT","Z","match","pop","floor","abs","S","$0","default","shortDate","mediumDate","longDate","fullDate","shortTime","mediumTime","longTime","isoDate","isoTime","isoDateTime","isoUtcDateTime","polyfill","define"],"mappings":"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"}