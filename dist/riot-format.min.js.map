{"version":3,"file":null,"sources":["../src/format.js","../src/index.js","../src/formatter.js","../src/formatters/date/dateFormat.js","../src/formatters/date/index.js","../src/formatters/number.js","../src/formatters/bytes.js","../src/formatters/json.js"],"sourcesContent":["import Formatter from './formatter'\n\n/**\n * Forbidden names when define formatters or retrieve formatter\n * @constant\n */\nconst ForbiddenMethods = ['value', 'toString', 'valueOf']\n\n/**\n* format a given value in the riot tag context\n* @example <caption>use it globally</caption>\n* format(new Date(), 'date');\n* @example <caption>use it with riot</caption>\n* window.format = format;\n* \n* //define a riot tag\n*   <app>\n*      <p> {format(new Date(), 'date', 'yyyy-mm-dd HH:MM:ss')} </p>\n*   </app>\n* @param {any} value      the value passed in to be formatted\n* @param {string} method  the format method to be used\n* @returns {Formatter} the Formatter instance\n*/\nexport function format (value, method, ...args) {\n  const self = new Formatter(value)\n  if (typeof method == 'string' && ForbiddenMethods.indexOf(method)==-1) {\n    const fn = self[method]\n    if (typeof fn === 'function') {\n      fn.apply(self, args)\n    }else if(!fn){\n        throw new Error('method not found: ' + method);\n    }\n  }\n  return self\n}\n\n/**\n * @param {String} method method name\n * @param {Function} fn method body\n */\nfunction defineFormatter (method, fn) {\n  if (typeof method == 'string' && ForbiddenMethods.indexOf(method)==-1 && typeof fn == 'function') {\n    Formatter.prototype[method] = function (...args) {\n      this.value = fn.apply(null, [this.valueOf()].concat(args))\n      return this\n    }\n  }\n}\n\n/**\n * @description extend with custom formatters\n * @example\n *  extend('yesno', function(input){\n *      return !!input ? 'yes' : 'no';\n *  });\n * @example\n *  extend({\n *      yes: function(input){\n *          return !!input ? 'yes' : '';\n *      },\n *      no: function(input){\n *          return !!!input ? 'no' : '';\n *      }\n *  });\n * \n * @param {String|Object} name if name is Object, means mutiple format methods;\n *  otherwise it is method name, should be used with fn\n * @param {Function} fn should be used if name is String\n */\nexport function extend (name, fn) {\n  if (typeof name === 'object') {\n    const obj = name\n    for (let key in obj) {\n      defineFormatter(key, obj[key])\n    }\n  }else {\n    defineFormatter(name , fn)\n  }\n}\n","import { format, extend } from './format'\n\n// import built-in formatters\nimport './formatters'\n\n/**\n * mixin format globally\n * @param {any} riot riot module object\n * @example\n * import * as riot from 'riot';\n * use(riot);\n */\nexport default function use(riot) {\n  riot.mixin({format})\n}\n\n/**\n * same as extend()\n * @see extend\n * @deprecated\n */\nuse.define = function (...args) {\n  console.warn('define() is deprecated, use extend() instead.')\n  return extend(args)\n}\n\nuse.extend = extend\n\nuse.format = format\n\n// use.Formatter = Formatter\nexport { format, extend } from './format'\n","/**\n * a decorator class to format value\n * @class\n */\nexport default class Formatter {\n  constructor (value) {\n    this.value = value\n  }\n\n  /**\n   * @description format the value to String\n   * @returns {String}\n   */\n  toString () {\n    // apply auto format\n    if (this.value instanceof Date && !isNaN(this.value.valueOf())) {\n      const date = this.date;\n      if(typeof date === 'function'){\n        return date.call(this, 'default').toString();\n      }\n    }\n    return String(this.value)\n  }\n\n  /**\n   * get current value\n   */\n  valueOf () {\n    return this.value\n  }\n}\n\n","// taken from http://stevenlevithan.com/assets/misc/date.format.js\n/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\nvar dateFormat = function () {\n  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|\"[^\"]*\"|'[^']*'/g,\n    timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n    timezoneClip = /[^-+\\dA-Z]/g,\n    pad = function (val, len) {\n      val = String(val)\n      len = len || 2\n      while (val.length < len) val = '0' + val\n      return val\n  }\n\n  // Regexes and supporting functions are cached through closure\n  return function (date, mask, utc) {\n    var dF = dateFormat\n\n    // You can't provide utc if you skip other args (use the \"UTC:\" mask prefix)\n    if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\\d/.test(date)) {\n      mask = date\n      date = undefined\n    }\n\n    // Passing date through Date applies Date.parse, if necessary\n    date = date ? new Date(date) : new Date\n    if (isNaN(date)) throw SyntaxError('invalid date')\n\n    mask = String(dF.masks[mask] || mask || dF.masks['default'])\n\n    // Allow setting the utc argument via the mask\n    if (mask.slice(0, 4) == 'UTC:') {\n      mask = mask.slice(4)\n      utc = true\n    }\n\n    var _ = utc ? 'getUTC' : 'get',\n      d = date[_ + 'Date'](),\n      D = date[_ + 'Day'](),\n      m = date[_ + 'Month'](),\n      y = date[_ + 'FullYear'](),\n      H = date[_ + 'Hours'](),\n      M = date[_ + 'Minutes'](),\n      s = date[_ + 'Seconds'](),\n      L = date[_ + 'Milliseconds'](),\n      o = utc ? 0 : date.getTimezoneOffset(),\n      flags = {\n        d: d,\n        dd: pad(d),\n        ddd: dF.i18n.dayNames[D],\n        dddd: dF.i18n.dayNames[D + 7],\n        m: m + 1,\n        mm: pad(m + 1),\n        mmm: dF.i18n.monthNames[m],\n        mmmm: dF.i18n.monthNames[m + 12],\n        yy: String(y).slice(2),\n        yyyy: y,\n        h: H % 12 || 12,\n        hh: pad(H % 12 || 12),\n        H: H,\n        HH: pad(H),\n        M: M,\n        MM: pad(M),\n        s: s,\n        ss: pad(s),\n        l: pad(L, 3),\n        L: pad(L > 99 ? Math.round(L / 10) : L),\n        t: H < 12 ? 'a' : 'p',\n        tt: H < 12 ? 'am' : 'pm',\n        T: H < 12 ? 'A' : 'P',\n        TT: H < 12 ? 'AM' : 'PM',\n        Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),\n        o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n        S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n    }\n\n    return mask.replace(token, function ($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)\n    })\n  }\n}()\n\n// Some common format strings\ndateFormat.masks = {\n  'default': 'ddd mmm dd yyyy HH:MM:ss',\n  shortDate: 'm/d/yy',\n  mediumDate: 'mmm d, yyyy',\n  longDate: 'mmmm d, yyyy',\n  fullDate: 'dddd, mmmm d, yyyy',\n  shortTime: 'h:MM TT',\n  mediumTime: 'h:MM:ss TT',\n  longTime: 'h:MM:ss TT Z',\n  isoDate: 'yyyy-mm-dd',\n  isoTime: 'HH:MM:ss',\n  isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n  isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n}\n\n// Internationalization strings\ndateFormat.i18n = {\n  dayNames: [\n    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',\n    'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n  ],\n  monthNames: [\n    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',\n    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'\n  ]\n}\n\ndateFormat.polyfill = function () {\n  // For convenience...\n  Date.prototype.format = function (mask, utc) {\n    return dateFormat(this, mask, utc)\n  }\n}\nexport default dateFormat\n","import { extend} from '../../format'\nimport dateFormat from './dateFormat'\n\nextend('date', function date (input, pattern) {\n  return dateFormat(input, pattern)\n})\n","import { extend} from '../format'\n\nextend('number', function number (input, fractionSize) {\n  if (fractionSize === void 0 || fractionSize < 0) {\n    fractionSize = 2\n  }\n  const num = Number(input)\n  if (isNaN(num.valueOf())) {\n    return input\n  }\n  if (!isFinite(num.valueOf())) {\n    return num.valueOf() < 0 ? '-∞' : '∞'\n  }\n  return num.toFixed(fractionSize).replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,')\n})\n","import { extend} from '../format'\n\nextend('bytes', function bytes (input, fractionSize = 2 , defaultValue = '--') {\n  const num = new Number(input)\n\n  if (isNaN(num.valueOf()) || num < 0) {\n    return defaultValue\n  }\n  if (fractionSize < 0) {\n    fractionSize = 2\n  }\n\n  if (num < 1024) {\n    return num.toFixed(0) + ''\n  }\n  if (num < 1024 * 1024) {\n    return (num / 1024).toFixed(fractionSize) + 'K'\n  }\n  if (num < 1024 * 1024 * 1024) {\n    return (num / (1024 * 1024)).toFixed(fractionSize) + 'M'\n  }\n  return (num / (1024 * 1024 * 1024)).toFixed(fractionSize) + 'G'\n})\n","import { extend} from '../format'\n\nextend('json', function json (input) {\n  return JSON.stringify(input)\n})\n"],"names":["format","value","method","const","self","Formatter","ForbiddenMethods","indexOf","fn","apply","args","Error","defineFormatter","prototype","this","valueOf","concat","extend","name","obj","let","key","use","riot","mixin","toString","Date","isNaN","date","call","String","dateFormat","token","timezone","timezoneClip","pad","val","len","length","mask","utc","dF","arguments","Object","test","undefined","SyntaxError","masks","slice","_","d","D","m","y","H","M","s","L","o","getTimezoneOffset","flags","dd","ddd","i18n","dayNames","dddd","mm","mmm","monthNames","mmmm","yy","yyyy","h","hh","HH","MM","ss","l","Math","round","t","tt","T","TT","Z","match","pop","replace","floor","abs","S","$0","default","shortDate","mediumDate","longDate","fullDate","shortTime","mediumTime","longTime","isoDate","isoTime","isoDateTime","isoUtcDateTime","polyfill","input","pattern","fractionSize","num","Number","isFinite","toFixed","defaultValue","JSON","stringify","define","console","warn"],"mappings":"wNAuBA,SAAgBA,GAAQC,EAAOC,gEAC7BC,IAAMC,GAAO,GAAIC,GAAUJ,EAC3B,IAAqB,gBAAVC,IAAsBI,EAAiBC,QAAQL,KAAS,EAAI,CACrEC,GAAMK,GAAKJ,EAAKF,EAChB,IAAkB,kBAAPM,GACTA,EAAGC,MAAML,EAAMM,OACX,KAAIF,EACN,KAAM,IAAIG,OAAM,qBAAuBT,GAG7C,MAAOE,GAOT,QAASQ,GAAiBV,EAAQM,GACX,gBAAVN,IAAsBI,EAAiBC,QAAQL,KAAS,GAAmB,kBAANM,KAC9EH,EAAUQ,UAAUX,GAAU,iEAE5B,OADAY,MAAKb,MAAQO,EAAGC,MAAM,MAAOK,KAAKC,WAAWC,OAAON,IAC7CI,OAyBb,QAAgBG,GAAQC,EAAMV,GAC5B,GAAoB,gBAATU,GAAmB,CAC5Bf,GAAMgB,GAAMD,CACZ,KAAKE,GAAIC,KAAOF,GACdP,EAAgBS,EAAKF,EAAIE,QAG3BT,GAAgBM,EAAOV,GChE3B,QAAwBc,GAAIC,GAC1BA,EAAKC,OAAOxB,OAAAA,ICTd,GAAqBK,GAAU,SAChBJ,GACba,KAAOb,MAAQA,EAOjBI,aAAEoB,oBAEA,GAAMX,KAAKb,gBAAiByB,QAASC,MAAMb,KAAKb,MAAMc,WAAY,CAChE,GAAQa,GAAOd,KAAKc,IACpB,IAAqB,kBAATA,GACV,MAASA,GAAKC,KAAKf,KAAM,WAAWW,WAGxC,MAASK,QAAOhB,KAAKb,QAMvBI,YAAEU,mBACA,MAASD,MAAKb,MFtBhBE,IAAMG,IAAoB,QAAS,WAAY,WGS3CyB,EAAa,WACf,GAAIC,GAAQ,iEACVC,EAAW,uIACXC,EAAe,cACfC,EAAM,SAAUC,EAAKC,GAGnB,IAFAD,EAAMN,OAAOM,GACbC,EAAMA,GAAO,EACND,EAAIE,OAASD,GAAKD,EAAM,IAAMA,CACrC,OAAOA,GAIX,OAAO,UAAUR,EAAMW,EAAMC,GAC3B,GAAIC,GAAKV,CAUT,IAPwB,GAApBW,UAAUJ,QAAuD,mBAAxCK,OAAO9B,UAAUY,SAASI,KAAKD,IAA+B,KAAKgB,KAAKhB,KACnGW,EAAOX,EACPA,EAAOiB,QAITjB,EAAOA,EAAO,GAAIF,MAAKE,GAAQ,GAAIF,MAC/BC,MAAMC,GAAO,KAAMkB,aAAY,eAEnCP,GAAOT,OAAOW,EAAGM,MAAMR,IAASA,GAAQE,EAAGM,MAAe,SAGlC,QAApBR,EAAKS,MAAM,EAAG,KAChBT,EAAOA,EAAKS,MAAM,GAClBR,GAAM,EAGR,IAAIS,GAAIT,EAAM,SAAW,MACvBU,EAAItB,EAAKqB,EAAI,UACbE,EAAIvB,EAAKqB,EAAI,SACbG,EAAIxB,EAAKqB,EAAI,WACbI,EAAIzB,EAAKqB,EAAI,cACbK,EAAI1B,EAAKqB,EAAI,WACbM,EAAI3B,EAAKqB,EAAI,aACbO,EAAI5B,EAAKqB,EAAI,aACbQ,EAAI7B,EAAKqB,EAAI,kBACbS,EAAIlB,EAAM,EAAIZ,EAAK+B,oBACnBC,GACEV,EAAGA,EACHW,GAAI1B,EAAIe,GACRY,IAAKrB,EAAGsB,KAAKC,SAASb,GACtBc,KAAMxB,EAAGsB,KAAKC,SAASb,EAAI,GAC3BC,EAAGA,EAAI,EACPc,GAAI/B,EAAIiB,EAAI,GACZe,IAAK1B,EAAGsB,KAAKK,WAAWhB,GACxBiB,KAAM5B,EAAGsB,KAAKK,WAAWhB,EAAI,IAC7BkB,GAAIxC,OAAOuB,GAAGL,MAAM,GACpBuB,KAAMlB,EACNmB,EAAGlB,EAAI,IAAM,GACbmB,GAAItC,EAAImB,EAAI,IAAM,IAClBA,EAAGA,EACHoB,GAAIvC,EAAImB,GACRC,EAAGA,EACHoB,GAAIxC,EAAIoB,GACRC,EAAGA,EACHoB,GAAIzC,EAAIqB,GACRqB,EAAG1C,EAAIsB,EAAG,GACVA,EAAGtB,EAAIsB,EAAI,GAAKqB,KAAKC,MAAMtB,EAAI,IAAMA,GACrCuB,EAAG1B,EAAI,GAAK,IAAM,IAClB2B,GAAI3B,EAAI,GAAK,KAAO,KACpB4B,EAAG5B,EAAI,GAAK,IAAM,IAClB6B,GAAI7B,EAAI,GAAK,KAAO,KACpB8B,EAAG5C,EAAM,OAASV,OAAOF,GAAMyD,MAAMpD,KAAc,KAAKqD,MAAMC,QAAQrD,EAAc,IACpFwB,GAAIA,EAAI,EAAI,IAAM,KAAOvB,EAAmC,IAA/B2C,KAAKU,MAAMV,KAAKW,IAAI/B,GAAK,IAAYoB,KAAKW,IAAI/B,GAAK,GAAI,GACpFgC,GAAI,KAAM,KAAM,KAAM,MAAMxC,EAAI,GAAK,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAM,IAAMA,EAAI,IAGhF,OAAOX,GAAKgD,QAAQvD,EAAO,SAAU2D,GACnC,MAAOA,KAAM/B,GAAQA,EAAM+B,GAAMA,EAAG3C,MAAM,EAAG2C,EAAGrD,OAAS,QAM/DP,GAAWgB,OACT6C,QAAW,2BACXC,UAAW,SACXC,WAAY,cACZC,SAAU,eACVC,SAAU,qBACVC,UAAW,UACXC,WAAY,aACZC,SAAU,eACVC,QAAS,aACTC,QAAS,WACTC,YAAa,wBACbC,eAAgB,gCAIlBxE,EAAWgC,MACTC,UACE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAC1C,SAAU,SAAU,UAAW,YAAa,WAAY,SAAU,YAEpEI,YACE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAC7E,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAAU,YAAa,UAAW,WAAY,aAIlHrC,EAAWyE,SAAW,WAEpB9E,KAAKb,UAAUb,OAAS,SAAUuC,EAAMC,GACtC,MAAOT,GAAWjB,KAAMyB,EAAMC,KC1HlCvB,EAAO,OAAQ,SAAewF,EAAOC,GACnC,MAAO3E,GAAW0E,EAAOC,KCF3BzF,EAAO,SAAU,SAAiBwF,EAAOE,IAClB,SAAjBA,GAA2BA,EAAe,KAC5CA,EAAe,EAEjBxG,IAAMyG,GAAMC,OAAOJ,EACnB,OAAI9E,OAAMiF,EAAI7F,WACL0F,EAEJK,SAASF,EAAI7F,WAGX6F,EAAIG,QAAQJ,GAAcpB,QAAQ,sBAAuB,OAFvDqB,EAAI7F,UAAY,EAAI,KAAO,MCTtCE,EAAO,QAAS,SAAgBwF,EAAOE,EAAmBK,kBAAJ,kBAAmB,KACvE7G,IAAMyG,GAAM,GAAIC,QAAOJ,EAEvB,OAAI9E,OAAMiF,EAAI7F,YAAc6F,EAAM,EACzBI,GAELL,EAAe,IACjBA,EAAe,GAGbC,EAAM,KACDA,EAAIG,QAAQ,GAAK,GAEtBH,EAAM,SACAA,EAAM,MAAMG,QAAQJ,GAAgB,IAE1CC,EAAM,YACAA,EAAM,SAAeG,QAAQJ,GAAgB,KAE/CC,EAAM,YAAsBG,QAAQJ,GAAgB,OCnB9D1F,EAAO,OAAQ,SAAewF,GAC5B,MAAOQ,MAAKC,UAAUT,KNkBxBnF,EAAI6F,OAAS,iEAEX,OADAC,SAAQC,KAAK,iDACNpG,EAAOP,IAGhBY,EAAIL,OAASA,EAEbK,EAAItB,OAASA"}